/**
 * @file profile.comp
 *
 * @brief Profile buffer compute shader
 *
 * @author Viktor Shubert
 * Contact: shubevik@fel.cvut.cz
 *
 */

#version 460 core

#extension GL_ARB_shading_language_include : require
#include "compute_macros.glsl"

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f) writeonly uniform image1DArray out_ProfileBuffer;

// Current discrete k
uniform int u_ik;
uniform float u_windSpeed;
// Lower Bound
uniform float u_kmin;
// Upper bound
uniform float u_kmax;
// Time since start
uniform float u_time;
// Profile buff. period
uniform float u_period;
// Profile buff. resolution
uniform uint u_resolution;
// Spectrum index
uniform int u_specIdx;


float dispersionRelation(float k)
{
    return sqrt(9.81 * k);
};

float tessendorf(float k)
{
	float g = 9.81;
	return (exp(-pow(g,2) / pow(k, 2) /pow(u_windSpeed/3, 4) ) / pow(k, 4));
}

float john(float k)
{
	float g = 9.81;
	float alpha = 0.0081;
	float beta = -0.74;
	float omega0 = g / (1.026 * u_windSpeed);
	float omegap = 0.855 * g / u_windSpeed;
	float omega = 0.345 * dispersionRelation(TAU / k);
	float sigma;
	if (omega <= omegap)
		sigma = 0.7;
	else
		sigma = 0.9;
	float r = exp(-pow(omega - omegap, 2) / 2 * pow(sigma * omegap, 2));
	return 0.04 * (alpha * g * g / pow(omega, 5) ) * exp(-beta * pow(omega0 / omega, 4)) * pow(0.33, r);
}

float pierson(float k)
{
	float g = 9.81;
	float alpha = 0.0081;
	float beta = -0.74;
	float omega0 = g / (1.026 * u_windSpeed);
	float omegap = 0.855 * g / u_windSpeed;
	float omega = min(dispersionRelation(TAU * k), omegap);
	return 0.04 * (alpha * g * g / pow(omega, 5) ) * exp(-beta * pow(omega0 / omega, 4));
}
float spectrum(float k)
{
	switch (u_specIdx)
	{
		case 1:
		return john(k);
		case 2:
		return tessendorf(k);
		default:
		return pierson(k);
	}
}

// Gerstner waves
vec4 calculateDisplacement(float phase, float k)
{
    float s = sin(phase);
    float c = cos(phase);
    return vec4(-s, c, - k * c, - k * s );
};


// Function to integrate
vec4 compute(float k, float p, float c)
{
	float knum = TAU / k; //angular wave number
	float phase1 = knum * p - dispersionRelation(knum) * u_time;
	float phase2 = knum * (p + u_period) - dispersionRelation(knum) * u_time;

	return k * spectrum(k) * mix(calculateDisplacement(phase2, knum), calculateDisplacement(phase1, knum), c);
}

void main()
{
	int pos = int(gl_GlobalInvocationID.x);
	
	float p = (float(pos * u_period) / u_resolution) + u_kmin;
	float c = p / u_period;

	float dx = (u_kmax - u_kmin) / INTEGRATION_SAMPLES;
	float x = u_kmin + 0.5 * dx;
	vec4 result = dx * compute(x, p, c);
	for (int i = 1; i < INTEGRATION_SAMPLES; ++i)
	{
		x += dx;
		result += dx * compute(x, p, c);
	}
	imageStore(out_ProfileBuffer, ivec2(pos, u_ik), result);
}