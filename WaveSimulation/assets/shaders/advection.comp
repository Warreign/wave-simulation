#version 460 core

#define PI 3.1415926538
#define TAU 6.282003266

#define X 0
#define Z 1
#define Theta 2

layout (local_size_x = 16, local_size_y = 16, local_size_z = 4) in;

uniform sampler3D samp[4];
uniform sampler3D in_Grid;
layout(r32f) uniform writeonly image3D out_Grid;

uniform int u_direction;
uniform float u_defAmplitude;

// Grid Dimensions
uniform ivec3 u_dim;
// Minimum values on the real grid
uniform vec3 u_min;
// Difference between discreet values of the grid
uniform vec3 u_delta;

// Group speed of current wave number
uniform float u_groupSpeed;
// Time step
uniform float u_dt;

float realPos(int idx, int dim)
{
	return u_min[dim] + (idx + 0.5) * u_delta[dim];
}

vec3 realPos(int ix, int iz, int itheta)
{
	return vec3(realPos(ix, X), realPos(iz, Z), realPos(itheta, Theta));
}

float gridPos(float val, int dim)
{
	return (val - u_min[dim]) / u_delta[dim] - 0.5;
}

vec3 gridPos(vec3 realPosition)
{
	return vec3(gridPos(realPosition.x,X), gridPos(realPosition.y, Z), gridPos(realPosition.z, Theta));
}

float defaultAmplitude(int itheta)
{
    if (itheta == u_direction)
        return u_defAmplitude;
    return 0.0;
}

void main()
{
	ivec3 pos = ivec3(gl_GlobalInvocationID);
	vec3 realPosition = realPos(pos[X], pos[Z], pos[Theta]);

	vec2 waveVector = vec2(cos(realPosition[Theta]), sin(realPosition[Theta]));

	realPosition = realPosition - u_dt * u_groupSpeed * vec3(waveVector, 0.0);
	vec3 gridPosition = gridPos(realPosition);
    
    int itheta = pos.z;

    float result;
	if (gridPosition[X] <= 0.0 || gridPosition[X]+1 >= u_dim[X] || gridPosition[Z] <= 0.0 || gridPosition[Z]+1 >= u_dim[Z])
	{
        itheta = (itheta + u_dim[Theta]) % u_dim[Theta];
		result = defaultAmplitude(itheta);
	}
    else
    {
	    vec3 texPos =  gridPosition/(u_dim) + 0.5/u_dim;
        result = texture(in_Grid, texPos).r;
    }


	imageStore(out_Grid, pos, vec4(result, 0, 0, 0));
}
