#version 460 core

#extension GL_ARB_shading_language_include : require
#include "compute_macros.glsl"
#include "compute_common.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 4) in;

uniform sampler3D samp[4];
uniform sampler3D in_Grid;
layout(r32f) uniform writeonly image3D out_Grid;

uniform int u_direction;
uniform float u_defAmplitude;

// Grid Dimensions
uniform ivec3 u_dim;
// Minimum values on the real grid
uniform vec3 u_min;
// Difference between discreet values of the grid
uniform vec3 u_delta;

// Group speed of current wave number
uniform float u_groupSpeed;
// Time step
uniform float u_dt;

float realPos(int idx, int dim)
{
	return u_min[dim] + (idx + 0.5) * u_delta[dim];
}

vec3 realPos(int ix, int iz, int itheta)
{
	return vec3(realPos(ix, X), realPos(iz, Z), realPos(itheta, Theta));
}

float gridPos(float val, int dim)
{
	return (val - u_min[dim]) / u_delta[dim] - 0.5;
}

vec3 gridPos(vec3 realPosition)
{
	return vec3(gridPos(realPosition.x,X), gridPos(realPosition.y, Z), gridPos(realPosition.z, Theta));
}

float defDirection = TAU / N_THETA * u_direction;
float defaultAmplitude(float theta)
{
//    if (itheta == u_direction)
//        return u_defAmplitude;
//    return 0.0;
	if (theta >= defDirection - 0.3 && theta < defDirection + 0.3)
		return u_defAmplitude;
	return 0.0;
}


vec2 cubepos = vec2(11, 15);
float cubescale = 8.0f;
bool insideCube(vec2 position)
{
	return (position.x >= cubepos.x - cubescale &&
			position.x <= cubepos.x + cubescale && 
			position.y >= cubepos.y - cubescale && 
			position.y <= cubepos.y + cubescale);
}

void main()
{
	ivec3 pos = ivec3(gl_GlobalInvocationID);
	vec3 realPosition = realPos(pos[X], pos[Z], pos[Theta]);

	vec2 waveVector = vec2(cos(realPosition[Theta]), sin(realPosition[Theta]));

	realPosition = realPosition - u_dt * u_groupSpeed * vec3(waveVector, 0.0);
	vec3 gridPosition = gridPos(realPosition);
    
    int itheta = pos.z;

    float result;
	if (gridPosition[X] <= 0.0 || gridPosition[X]+1 >= u_dim[X] || gridPosition[Z] <= 0.0 || gridPosition[Z]+1 >= u_dim[Z])
	{
        itheta = (itheta + u_dim[Theta]) % u_dim[Theta];
		result = defaultAmplitude(realPosition[Theta]);
	}
    else
    {
	    vec3 texPos =  gridPosition/(u_dim) + 0.5/u_dim;
        result = texture(in_Grid, texPos).r;
    }

//	if (insideCube(realPosition.xy))
//	{
//		result = 0.2;
//	}
//
	imageStore(out_Grid, pos, vec4(result, 0, 0, 0));
}
